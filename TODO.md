# Ultra Short Term TODOs -- Code Generation

* [X] Hierarchical dependency graph
    - [X] SSA code generation
    - [X] lazy execution of if statement branches
* [X] Fusion
    - [X] ~~Move fusion stuff to `soap.semantics.state.fusion`~~
    - [X] Restructure `FixExpr` to use `bool_expr`, `meta_state` and `var`
    - [X] Consider how to deal with duplicates. Example:
            Program `n := n + 1; while (x < n) (x := x + 1)` gives
            [x ↦ fix(λe̲.(x < n ? e̲ % [x ↦ x + 1] : x)) % [x ↦ x, n ↦ n + 1],
             n ↦ n + 1]
    - [X] `loop_fusion`
    - [X] `interscope_fusion`
* [ ] Code generation
    - [ ] Dependency graph `External` expression special casing
    - [ ] `FixExpr`
* [ ] Fix crazy closure edges generated by `expression_dependencies`


# Ugliness, fix if have the time to

* [ ] {Possible} Better code generation by expanding expressions with locals
    - [ ] Instead of sets of edges, consider using bags of edges to model
          dependency graph.
* [ ] {Possible} Add dependency ordering utility function
    - [ ] ~~Use this for code generation node ordering, kill nondeterminism~~
    - [ ] For killing nondeterminism in labelling
    - [ ] For code generation
    - [ ] For loop merging


# Short Term TODOs -- Soap 2

* [ ] Equivalent expression relations for the following expressions/operators:
    - [ ] `SelectExpr`
    - [ ] `LinkExpr`
    - [ ] `FixExpr`
* [ ] Resource usage statistics generation for the following operators:
    - [ ] Comparisons
    - [ ] Branches (Multiplexer?)
* [ ] Make use of loop invariants in optimisation
    - [ ] Identifier-based error analysis
* [ ] Relational domain (if possible), because currently branch constraints
      could be too restrictive to be useful, and sometimes constraints cannot
      be discovered
* [ ] Special casing for `FixExpr` expansion, because simply expanding
      (unrolling) preserves floating-point semantics (same error) but double
      the resource usage, thus optimised away by the Pareto frontier.
