# Ultra Short Term TODOs -- Transforms

* [ ] Equivalent expression relations for the following expressions/operators:
    - [ ] `SelectExpr`
    - [ ] `FixExpr`
* [ ] Resource usage statistics generation with XST for the following
  operators:
    - [ ] Comparisons
    - [ ] Branches (Multiplexer?)
* [ ] Make use of loop invariants in optimisation
    - [ ] Identifier-based error analysis
* [ ] Relational domain (if possible), because currently branch constraints
  could be too restrictive to be useful, and sometimes constraints cannot
  be discovered
* [ ] Special casing for `FixExpr` expansion, because simply expanding
  (unrolling) preserves floating-point semantics (same error) but double
  the resource usage, thus optimised away by the Pareto frontier.


# Ugliness, fix if have the time to

* [ ] {Possible} Better code generation by expanding expressions with locals
    - [ ] Instead of sets of edges, consider using bags of edges to model
      dependency graph.
* [ ] {Possible} Add dependency ordering utility function
    - [ ] ~~Use this for code generation node ordering, kill nondeterminism~~
    - [ ] For killing nondeterminism in labelling
    - [ ] For code generation
    - [ ] For loop merging


# Future Considerations

* [ ] General program transform
    - [X] Metasemantics
    - [ ] Transforms
        - [ ] Extend equivalent relations
        - [ ] Update `greedy_frontier`
    - [ ] Analysis
        - [X] Resource usage
        - [X] Error analysis
        - [ ] Latency
    - [X] Code generation
* [ ] Multiple mantissa widths
* [ ] Fixed point format
* [ ] Fix and write more test cases


# Reminders

* [ ] Actually use `context.window_depth` and `context.precision`
* [ ] Deprecate prec arguments, because of context support


# Completed

* [X] Code generation
    - [X] Hierarchical dependency graph
        - [X] SSA code generation
        - [X] lazy execution of if statement branches
    - [X] Fusion
        - [X] Move fusion stuff to `soap.semantics.state.fusion`
        - [X] Restructure `FixExpr` to use `bool_expr`, `meta_state` and `var`
        - [X] Consider how to deal with duplicates. Example:
          Program `n := n + 1; while (x < n) (x := x + 1)` gives
          [x ↦ fix(λe̲.(x < n ? e̲ % [x ↦ x + 1] : x)) % [x ↦ x, n ↦ n + 1],
          n ↦ n + 1]
        - [X] `loop_fusion`
        - [X] `inner_meta_fusion`
        - [X] `outer_scope_fusion`
    - [X] `FixExpr` code generation
        - [X] `DependencyGraph` `External` expression special casing
        - [X] `emit_FixExpr`
    - [X] Fix crazy closure edges generated by `expression_dependencies`
