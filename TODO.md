# Ultra Short Term TODOs -- Transforms

* [ ] Equivalence rules for the following operator/expression types
    - [ ] `SelectExpr`
        - [ ] Distributivity
        - [ ] Commutativity?
* [ ] Relational domain (if possible), because currently branch constraints
  could be too restrictive to be useful, and sometimes constraints cannot
  be discovered


# Ultra Short Term FIXMEs

* [ ] Fix numerical analysis bugs in corner cases.
    - [ ] Infinite bounds
    - [ ] Bottoms and tops
    - [ ] Float interval only rather than float interval + error interval in
      analysis results.
* [ ] Use fusion in resource usage analysis.
    - [ ] Add `out_vars` to discoverer and labelling arguments.


# Ugliness, fix if have the time to

* [ ] Get rid of identifier based analysis, no longer required.
* [ ] Generated code has boolean expressions assigned to variables, consider
  other approaches to analysing conditionals because of this.
* [ ] {Possible} Better code generation by expanding expressions with locals
    - [ ] Instead of sets of edges, consider using bags of edges to model
      dependency graph.
* [ ] {Possible} Add dependency ordering utility function
    - [ ] For labelling determinism
    - [ ] For code generation node ordering determinism
    - [ ] For loop merging


# Future Considerations

* [ ] Latency analysis
* [ ] Multiple mantissa widths
* [ ] Fixed point format
* [ ] Fix and write more test cases
* [ ] More operators, needs parsing, transform rules, metasemantics analysis,
  numerical analysis, resource usage analysis
    - [ ] Comparisons?
    - [ ] Power, exponentiation, logarithm


# Reminders

* [ ] Actually use `context.window_depth` and `context.precision`
* [ ] Deprecate prec arguments, because of context support


# Completed

* [X] Code generation
    - [X] Hierarchical dependency graph
        - [X] SSA code generation
        - [X] lazy execution of if statement branches
    - [X] Fusion
        - [X] Move fusion stuff to `soap.semantics.state.fusion`
        - [X] Restructure `FixExpr` to use `bool_expr`, `meta_state` and `var`
        - [X] Consider how to deal with duplicates. Example:
          Program `n := n + 1; while (x < n) (x := x + 1)` gives
          [x ↦ fix(λe̲.(x < n ? e̲ % [x ↦ x + 1] : x)) % [x ↦ x, n ↦ n + 1],
          n ↦ n + 1]
        - [X] `loop_fusion`
        - [X] `inner_meta_fusion`
        - [X] `outer_scope_fusion`
    - [X] `FixExpr` code generation
        - [X] `DependencyGraph` `External` expression special casing
        - [X] `emit_FixExpr`
    - [X] Fix crazy closure edges generated by `expression_dependencies`
* [X] Fix nested loop code generation generating incorrect variable names
* [X] Equivalent expression relations for the following expressions/operators:
    - [X] `SelectExpr`
    - [X] `FixExpr`
    - [X] `MetaState`
* [X] Special casing for `FixExpr` expansion, because simply expanding
  (unrolling) preserves floating-point semantics (same error) but double
  the resource usage, thus optimised away by the Pareto frontier.
* [X] Make use of loop invariants in optimisation
* [X] Resource usage statistics generation with XST for the following
  operators:
    - [X] Comparisons
    - [X] Branches (Multiplexer?)
    - [X] Divisions
    - [X] Squarer
    - [X] Power
    - [X] Exponentiation
    - [X] Logarithm
