# Ultra Short Term TODOs -- Transforms

* [ ] Integer types resource usage estimation
* [ ] Relational domain (if possible), because currently branch constraints
  could be too restrictive to be useful, and sometimes constraints cannot
  be discovered


# Ultra Short Term FIXMEs

* [X] Fix numerical analysis bugs in corner cases.
    - [X] Infinite bounds
    - [X] Bottoms and tops
    - [X] Float interval only rather than float interval + error interval in
      analysis results.
* [X] Check if it keeps changing precision and invalidating caches.
* [ ] Consider what is a reasonable thing to do with non-terminating
  expressions


# Ugliness, fix if have the time to

* [ ] Fix improper `out_vars` usage, workaround: use full variable list
    - [ ] Codegen not generating part of loop body because of
      improper `out_vars` analysis
    - [ ] Resource usage analysis should not count unnecessary part of the
      program, specified by `out_vars`
  Example::
        greedy(
            flow_to_meta_state(
                'y = 1\nwhile y < 10:\n x = x + 1 / y\n y = y + 1'),
            s['x':[0.0, 1.1]])
* [ ] Get rid of identifier based analysis, no longer required.
* [ ] Generated code has boolean expressions assigned to variables, consider
  other approaches to analysing conditionals because of this.
* [ ] {Possible} Better code generation by expanding expressions with locals
    - [ ] Instead of sets of edges, consider using bags of edges to model
      dependency graph.
* [ ] {Possible} Add dependency ordering utility function
    - [ ] For labelling determinism
    - [ ] For code generation node ordering determinism
    - [ ] For loop merging


# Future Considerations

* [ ] Latency analysis
* [ ] Multiple mantissa widths
* [ ] Fixed point format
* [ ] Fix and write more test cases
* [ ] More operators, needs parsing, transform rules, metasemantics analysis,
  numerical analysis, resource usage analysis
    - [ ] Comparisons?
    - [ ] Power, exponentiation, logarithm


# Reminders

* [ ] Actually use `context.window_depth` and `context.precision`
* [ ] Deprecate prec arguments, because of context support


# Completed

* [X] Code generation
    - [X] Hierarchical dependency graph
        - [X] SSA code generation
        - [X] lazy execution of if statement branches
    - [X] Fusion
        - [X] Move fusion stuff to `soap.semantics.state.fusion`
        - [X] Restructure `FixExpr` to use `bool_expr`, `meta_state` and `var`
        - [X] Consider how to deal with duplicates. Example:
          Program `n := n + 1; while (x < n) (x := x + 1)` gives
          [x ↦ fix(λe̲.(x < n ? e̲ % [x ↦ x + 1] : x)) % [x ↦ x, n ↦ n + 1],
          n ↦ n + 1]
        - [X] `loop_fusion`
        - [X] `inner_meta_fusion`
        - [X] `outer_scope_fusion`
    - [X] `FixExpr` code generation
        - [X] `DependencyGraph` `External` expression special casing
        - [X] `emit_FixExpr`
    - [X] Fix crazy closure edges generated by `expression_dependencies`
* [X] Fix nested loop code generation generating incorrect variable names
* [X] Equivalent expression relations for the following expressions/operators:
    - [X] `SelectExpr`
    - [X] `FixExpr`
    - [X] `MetaState`
* [X] Special casing for `FixExpr` expansion, because simply expanding
  (unrolling) preserves floating-point semantics (same error) but double
  the resource usage, thus optimised away by the Pareto frontier.
* [X] Make use of loop invariants in optimisation
* [X] Resource usage statistics generation with XST for the following
  operators:
    - [X] Comparisons
    - [X] Branches (Multiplexer?)
    - [X] Divisions
    - [X] Squarer
    - [X] Power
    - [X] Exponentiation
    - [X] Logarithm
* [X] Equivalence rules for the following operator/expression types
    - [X] `SelectExpr`
        - [X] Distributivity
        - [X] Commutativity?
* [X] Use fusion in resource usage analysis.
    - [X] Add `out_vars` to discoverer and labelling arguments.
* [X] Check why short Pareto frontier on unrolling, since there should always
  be trade-offs between unroll levels. Turns out to be a bug in LUTs counting
* [X] Check `inner_meta_state` fusion is using the correct `out_vars`,
  potential bug when non-existent variable is used to fuse stuff.
* [X] Add a util function for code gen
